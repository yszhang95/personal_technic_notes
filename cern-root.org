#+TITLE: Tips for ROOT6
* Library generation
** Build your own shared library
    See this [[https://root-forum.cern.ch/t/shared-libraries-interpreter-vs-compiled-macro/29389][post]] and this [[https://root.cern/manual/interacting_with_shared_libraries/][link]].
    Make use of ~rootcling~ and ~root-config~ to generate ~rootmap~.
    To make ~rootmap~ work, append the path to ~rootmap~ to
    ~LD_LIBRARY_PATH~ or its equivalence.
    My example codes are posted below.
    #+NAME: File system structure
    #+begin_verse
    .
    ├── Linkdef.h
    ├── Makefile
    ├── Inner.cc
    ├── Outer.cc
    ├── Inner.h
    └── Outer.h
    #+end_verse

    #+name: Linkdef.h
    #+begin_src c++
    /* Linkdef.h */
    #ifdef __CLING__
    #pragma link off all globals;
    #pragma link off all classes;
    #pragma link off all functions;
    #pragma link C++ nestedclasses;

    #pragma link C++ class Outer+;
    #pragma link C++ class Inner+;

    #endif
    #+end_src

    #+name: Makefile
    #+begin_src shell
# Makefile
CXXFLAGS=-std=c++14 -fPIC -I$(shell root-config --incdir)
LDFLAGS=$(shell root-config --libs)
CXX=g++

all: libMyClass.so

libMyClass.so: Outer.cc Inner.cc MyClassDict.cxx
	$(CXX) -shared -o $@ $(CXXFLAGS) $(LDFLAGS) $^

MyClassDict.cxx: Outer.h Inner.h Linkdef.h
	rootcling -f $@ -rmf MyClassDict.rootmap -rml libMyClass.so $^

.PHONY: clean
clean:
	rm -rf MyClassDict* libMyClass.so
    #+end_src

    #+name: Outer.h
    #+begin_src C++
/* Outer.h */
#include "TString.h"
#include <iostream>

class Outer
{
  public:
    Outer();
  private:
    TString _outer;
};

    #+end_src

    #+name: Outer.cc
    #+begin_src C++
/* Outer.cc */
#include "Outer.h"

using std::cout;
using std::endl;

Outer::Outer (): _outer("outer")
{
  cout << _outer << endl;
}
    #+end_src

    #+name: Inner.h
    #+begin_src c++
#include "TString.h"
#include <iostream>
/* Inner.h */
class Inner
{
 public:
  Inner();
 private:
  TString _inner;
};
    #+end_src

    #+NAME: Inner.cc
    #+begin_src c++
/* Inner.cc */
#include "Inner.h"

using std::cout;
using std::endl;

Inner::Inner (): _inner("inner")
{
  cout << _inner << endl;
}
    #+end_src

* Built-in functions
** Efficiency plots                                                             :NOTE:
   :PROPERTIES:
   :GROUP:    root
   :END:
 [2021-11-11 Thu 16:47]

 ~TH1::Divide~ can give errors accounting for binomial distributions if
 you supply ~"B"~ option. However, it won't give error if ~#pass = #total~.
 It is recommended to use ~TGraphAsymmErrors::Divide~ instead.

** User-defined functions in cling/rootcling                                    :NOTE:
   :PROPERTIES:
   :GROUP:    root
   :END:
 [2021-11-28 Sun 16:05]

 Functions cannot be auto-loaded without c++ modules. However, [[https://root-forum.cern.ch/t/using-user-defined-function-in-cling/36049][one]]
 mentioned that the putting the function inside a namespace or a class.
 I cannot manage to do it via a namespace but a class.

** How to generate string using =Form= and =Format=
   Please check this [[https://root-forum.cern.ch/t/question-on-tstring-form/27587/3][link]]. I copied the response from Philippe below
   and reinterpret a bit. In summary, it is recommended to use
   =TString::Form= and =TString::Format=, rather than the two globally
   defined functions, =::Form= and =::Format=.

   - =TString::Form= modifies an existing =TString=
   - =TString::Format= is a static function and it create a new =TString=.
   - =::Form= and =::Format=, using these two, you need to make sure
     that the result is not being passed to a function that itself
     will call one of these two functions as it would ‘overwrite’ the
     buffer while it is being used. These two functions date back to a
     time when creating temporary object and especially copying them
     (i.e. no move semantic) was very expansive.

   A solution to generate =C++= string can be found in the [[https://stackoverflow.com/questions/2342162/stdstring-formatting-like-sprintf][link]].

** How to add include path and load the libraries
   See the [[https://root-forum.cern.ch/t/problem-loading-customized-style-while-launching-root/18664/11][discussions]]. The inclue path need to be added and the
   library needs to be added before the macro is loaded/executed.
   One way to do is to create a =rootlogon.C= file:
   #+begin_src c++
     gInterpreter->AddIncludePath("path/to/dir");
     gSystem->Load("libMyClass.so");
   #+end_src
   You could do it via the MACRO =R__ADD_INCLUDE_PATH=, and
   =R__LOAD_LIBrARY=, if you do not want to create a =rootlogon.C=
   file. See the doc for [[https://root.cern/doc/master/Rtypes_8h.html][Rtypes]]. These macros cannot be recognized by
   =ACLiC=, so you have to hide them using =__CLING__=, (I do not know if
   I need =__ROOTCLING__=).
   #+begin_src c++
     // note, there is no "".
     #if defined(__CLING__)
     R__ADD_INCLUDE_PATH(/path/to/dir)
     R__LOAD_LIBRARY(path/to/lib)
     #endif
     #include "MyInclude.hpp"
   #+end_src

   There was another method in the user-guide. It looks like:
   #+begin_src c++
     // check to see if the event class is in the dictionary
     // if it is not load the definition in libEvent.so
     if (!TClassTable::GetDict("Event")) {
       gSystem->Load("$ROOTSYS/test/libEvent");
     }
   #+end_src
   You can find it the chapter =TTree= and in old ROOT source code, for
   example, the [[https://github.com/root-project/root/blob/v6-08-00-patches/tutorials/tree/tree4.C][6-08-00 patch]]. It does not work anymore. Now it is
   replaced with =R__LOAD_LIBRARY= if you trace the changes under
   different tags. ROOT team may need to update the user-guide in the
   future. See the [[https://github.com/root-project/root/blob/master/tutorials/tree/tree4.C][GitHub Link]].
